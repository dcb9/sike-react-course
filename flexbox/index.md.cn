

# Flexbox 布局

最初的 CSS [可视化渲染模型](http://www.w3.org/TR/WD-CSS2/cover.html#toc) 起草与 1998 年，那时候大部分页面都是文档，而且制作运行在浏览器中的应用是一个激进的想法。Web 从那之后已经进化多次了，但是我们仍旧用着同样陈旧的来自 1998 年的布局引擎。CSS 2 是被公认的技术，社区知识内容有很多（bad translation），这是巨大的痛苦。

举个例子，如果你想垂直居中某些内容，没有一种确定的方法来实现它，但有很多种在特殊情况下工作的方法：

![](css-vertical-centering.jpg)



为了成为一名称职的前端开发者，你需要去学习各种各样古怪、丑陋、不自然的敲门来处理不同的布局需求。

Flexbox，相反，是被特别设计为现代 web 创造 UI 的。它并不简单，而且就像其他复杂的布局系统一样，你有时候会发现它的行为令人惊讶。但是几乎所有情况下，总有一个简单的解释为什么。

需要实践才能把 flexbox 用好。但是相比于传统 CSS 布局方法，flexbox 简单多了！



### 我们的任务

在本次课程中我们将用 flexbox 实现 web 页面的基本布局：

![](ilove-react-layout-only.jpg)



# 设计规范

如果你有 Sketch，你可以下载原始的 Sketch 文件：

[ilovereact-plain.sketch](ilovereact-plain.sketch)

如果你没有 Sketch，你可以下载带有注解的设计：

[![](annotated-layout.jpg)](annotated-layout.jpg)



# 下载设计资源

你可以从这个仓库下载所有的设计资源：

[hayeah/iLoveReact-assets](https://github.com/hayeah/iLoveReact-assets)

把这些图片添加到你项目的 `img` 目录。



# Flex 介绍

[Flexbox 完整指南](https://css-tricks.com/snippets/css/a-guide-to-flexbox/) 里有所有有关 flexbox 的 CSS 属性的总结。这篇文章的讲解对于初次接触 Flexbox 相关属性的人来说信息量有点过大（bad translation）。

所以我们先从 Flexbox 的三个属性开始：`flex-direction`，`align-items`，`justify-content`。



+ `flex-direction` - 子元素是水平排列还是垂直排列。

  ![](flex-direction.jpg)

+ `align-items` 和 `justify-content` - 控制着子元素如何在父容器中排列。

  ![](flex-align-justify.jpg)


+ 把元素在容器里同时水平和垂直居中：

  ![](flex-centering.jpg)



对齐属性 `align-items` 和 `justify-content` 很容易混在一起使用。

+ `justify-content` - 控制着元素应该放在箭头的什么位置。
  + 这是 flex 容器的“主轴”。
+ `align-items` - 控制着箭头应该放在容器的什么位置。
  + 这是 flex 容器的“横轴”。



因此 `align-items: center` 意为根据 flex-direction 的值，决定水平居中或者垂直居中。一个帮助我们记住这个方法是理解 `align-self` 属性。

`align-self` 可以对 flex 容器中得一个特殊的元素的 `align-item` 赋不同的值。



```css
.container {
  flex-direction: row;
  align-items: center;
  justify-content: center;
}

.red {
  /* 只有一个元素那就是 `flex-start` */
  align-self: flex-start;
}
```



`align-self` 应该做了些什么？`align-self`不应该把 item 沿着 flex-direction（主轴）移动，否则 `.red` 元素的顺序会改变：

![](align-self-bad-design.jpg)



`align-self` 应该把元素按照横轴轴的方向移动，因此行的水平顺序保持相同：

![](flex-align-self.jpg)

根据这个原因，很简单就能基础 `align-self` 的方向。而且 `align-items` 和 `align-self` 方向相同。



# 页面样式

让我们首先定义页面的文字样式和背景颜色：



```css
body {
  background-color: #1F1E34;
  color: #FFF;
  font-family: "Avenir Next",
      "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica,
      Arial, "Lucida Grande", sans-serif;
  font-weight: 100;
}

h1 {
  font-size: 64px;
  font-weight: 100;
}

h2 {
  font-size: 48px;
  font-weight: 100;
}

p {
  font-size: 24px;
}

a {
  font-weight: 400;
  color: #FFF;
}

a:hover {
  font-weight: 400;
  color: #DADADA;
  text-decoration: none;
}
```



# 页面布局

### 练习：页面的部分

这个网页有四个部分。你应该让每个章节的宽高和屏幕一样。

为了让它们可见度更高，你可以暂时把它们的背景设为红色：



```css
.section {
  background-color: rgba(255,0,0,0.3);
  border: 2px solid #FFF;
}
```



这些部分应该看起来像：

<video src="fullpage-sections.mp4" controls></video>



### 练习：标题和 Logo

把下面的代码添加到第一个部分：



```html
<img class="react-logo" src="img/react-logo.svg"/>
<h1>Build Native Apps With React</h1>
```



你的结果：

![](title-and-logo.jpg)



### 练习：导航链接

因为元素在单一的 flex 容器只能按照一个方向排列，如果一些元素垂直排列，一些其他的元素水平排列，你需要嵌套使用 flex 容器。

![](flex-nesting.jpg)



+ 添加一个水平 flex 容器容纳导航链接。
+ 添加 padding 让它们分开。



```html
<a href="#native">
  Native iOS
</a>

<a href="#touch">
  Touch Handling
</a>

<a href="#async">
  Asynchronous
</a>

<a href="#flex">
  Flex &amp; Styling
</a>
```



你的结果：

![](navlinks.jpg)



# Flex-Grow 和延伸

{呀，我靠。flex-grow 笨死了。如果内容太多，它会变得无限长。太蠢了。}

我们下一个目标是把页面分为两个相等的部分：

![](left-right-partitions-no-content.jpg)

完成这项工作的直接方式是把宽度设置为 50%，高度设置为 100%。但是在这个练习中，我们将要使用 flexbox。首先，让我们把下面的 html 添加到第二部分：



```html
<div class="iphone-demo">
  iphone demo
</div>

<div class="feature-description">
  awesome feature description
</div>
```

```css
.iphone-demo {
  background-color: rgba(255,0,0,0.3);
}

.feature-description {
  background-color: rgba(0,255,0,0.3);
}
```



一开始，这两个容器就很大，足够容纳它们的文字内容：

![](flex-grow-none.jpg)

如果你想要移除它们的内容，他们会折叠成一个 0x0 的盒子（尝试下！）。



你可以设置两个属性使 flexbox 比它的内容更大：

+ `align-self: stretch` - 沿着横轴的方向拉伸元素。
+ `flex-grow: 1` - 沿着主轴的方向拉伸元素。



正如 `align-items` 和 `justify-content`，它们的行为取决于 flex direction：

![](flex-and-stretch.jpg)



为什么 `flex-grow` 是个数字？如果 `flex-grow` 为 0，那个元素就不会扩大。否则，这个数字就是元素应该拉伸覆盖可用空间的比例。

![](flex-grow-factor.jpg)



就具体的例子而言，我们可以让第一个容器占有 1/3 的空间，让第二个容器占有 2/3 的空间：



```css
.iphone-demo {
  flex-grow: 1;
  background-color: rgba(255,0,0,0.3);
}

.feature-description {
  flex-grow: 2;
  background-color: rgba(0,255,0,0.3);
}
```

![](flew-grow-1-and-2.jpg)



### 练习：左右布局

使用 `flex-grow` 和 `align-self` 把第二部分分成两半。

你的结果：

![](left-right-partitions-no-content.jpg)



注：确保这些容器是空得。如果一个容器内容的数量超过了其他容器，这个容器就会比其他的大。

![](flex-basis-auto.jpg)

我们讲在下个课程中修复这个问题。



# Flex 基础

Flexbox 的大小由两个因素决定：

1. Flexbox 中的内容有多少。
2. 父容器中有多少空闲空间。如果 `flex-grow` 为非零值，它会扩大填满这些空间。



```html
<div class="feature-description">
  <h2>Native Experience</h2>
  <p>
    Takes advantage of native iOS components to give your app a consistent look and feel with the rest of the platform ecosystem, and keeps the quality bar high.
  </p>
</div>
```



它扩张来适配一行的内容，从左容器中挤出去了：

<video src="flex-basis-auto-greedy.mp4" controls loop></video>



理解这种行为的关键是“空闲空间”的数量是在容器适配内容扩张之后才计算的：

![](flex-basis-auto-free-spzce.jpg)



然后空闲空间根据 `flew-grow` 因素划分。这就解释了为什么容器宽度不同：

![](flex-basis-auto.jpg)



当计算空闲空间时，我们可以使用 `flex-basis` 属性覆盖 flexbox 的大小。如果我们给子元素设置了 `flex-basis: 0`，当它们的父容器计算空闲空间时，它们的宽度就好像为零一样。空闲空间（整个父容器的宽度）后来被这两个子元素分割了：

![](flex-basis-zero.jpg)



`flex-basis` 属性就像是 flexbox 的最小值。它决定了 flexbox 给自己保留多少空间。默认的 `flex-basis: auto` 意为“保留尽可能多的空间来适配内容”。`flex-basis: 50px` 意为保留 50 像素，但是如果有更多空闲空间就会扩大。



### 练习：适应 Flex-Basis

添加到第二部分：

```html
<div class="iphone-demo">
  <img src="img/iphone-frame.svg"/>
</div>

<div class="feature-description">
  <h2>Native Experience</h2>
  <p>
    Takes advantage of native iOS components to give your app
    a consistent look and feel with the rest of the platform ecosystem,
    and keeps the quality bar high.
  </p>
</div>
```



添加到第三部分：

```html
<div class="iphone-demo">
  <img src="img/iphone-frame.svg"/>
</div>

<div class="feature-description">
  <h2>Touches &amp; Gestures</h2>
  <p>
    React Native implements a powerful responder system to
    negotiate touches in complex view hierarchies. It allows you
    to build complex UI, and handle user interactions precisely.
  </p>
</div>
```

你的结果：

![](feature-layout-done.jpg)



# Android 即将到来

### 练习：添加“Android Is Here”

在最后的部分，添加：

```html
<h1>Android Is Here</h1>
```

结果：

![](android-is-here.jpg)



# Flex: 1

在 ReactNative 里你会经常看到神秘的设定 `flex: 1` 来扩大一个 flexbox。`flex` 是同时设置 `flex-grow`，`flex-shrink` 和 `flex-basis` 的简写。默认为：

```css
flex: 0 1 auto;
/*
flex-grow: 0;
flex-shrink: 1;
flex-basis: auto;
*/
```



`flex: 1` 意为 `flex: 1 1 auto`，或者写为完整形式：

```css
flex-grow: 1;
flex-shrink: 1;
flex-basis: auto;
```



# 总结

有很多属性和可能的设定。刷新你记忆的不错参考：

+ [CSS Tricks - A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)

如果你碰到了一个奇怪的布局问题，阅读规范，理解准确的行为通常来得更快：

+ [CSS Flexible Box Layout Module Level 1](http://www.w3.org/TR/css-flexbox-1)



控制使用哪个轴（水平或者垂直）来排列元素：

+ `flex-direction: row`, `flex-direction: column`



控制元素在容器的什么位置（对着一条边，或者聚众）：

+ `align-items`, `align-self`, `justify-content`



控制元素如何扩大或收缩：

+ `flex-grow`, `flex-basis`, `flex-shrink`, `align-self: stretch`



简写：

+ `flex: 1` 意为 `flex-grow: 1; flex-shrink: 1; flex-basis: auto;`

